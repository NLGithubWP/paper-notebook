IntegriDB: Verifiable SQL for Outsourced Databases

# INTRODUCTION

## Problems

## 

An authenticated data structure (ADS) could be used to verify queried data.

`Prior work` used to construct ADS handling some subset of SQL queries `can be classified into two categories`:

1. Generic approaches:
   - Data owner first compile database into a program (circuit / RAM-model of computation.) which accepts query as input and return result.
   - Size of circuit is as large as database.
   - Circuit-based approach not allow efficient updates.
2. Specific approaches:
   - Tree-based (Merkel tree) / Signature-based (data in server is pre-signed by data owner)
   - Both of them only support single-dimensional range queries.
   - Both of them don't support updates.

Generic approach taks large memory space, Specific approach is limited in dimension. Both of them `don't support short proofs` for (join, sum, max, min, count)

## Contributaion

The paper designing an ADS and an associated system that supports *native SQL queries* over a relational database, Such a system would be suitable for integration into the most prevalent applications running in the cloud today, and could be offered as a software layer on top of any SQL implementation.

1. expressive: supports multidimensional range queries and nesting queries. 
2. efficient: `small proofs`(few kb), low verification time, feasible server computation.
3. scalable: can excuted on DB table with 6 million rows.
4. cryptographic assumptions: based on crypto-graphic assumptions

# PRELIMINARIES

## Authenticated Data Structure

Three roles, server, data owner, client

ADS for query Q and U consists of efficient algorithms `init, setup, prove, cerify, UpdateO, UpdateS`

D: data, D': encrypted data, R: Result, pi: Proof, Q: Query, lambda: secure parameter

1. `(data owner)` Init:  lambda => <pk, sk>
2. `(data owner)` Setup: ( D, sk ) => ( digest, D' ), and send D' to server, publish (digest, pk)
3. `(Server)` Prove: ( digest, D', Q) => (R, pi)
4. `(client)` Verify: ( digest, Q, R, pi) => 0 or 1
5. `UpdateO/UpdateS`: Interactive algorithm run by data owner and server. 
   - UpdateO: ( sk, digest, update ) => ( digest, 0/1 indicting accept or reject )
   - UpdateS:  D' => D'

## SQL queries supported by IntegriDB

**Multidimensional range query**

multiple columns and range filter for each column

```sql
SELECT * FROM A WHERE (age BETWEEN 22 AND 24) AND (student_ID > 10730)
```

Join, Sum, Max, Min, COunt, Like, Nested Query.

# BUILDING BLOCKS

## ADS for set operations with Summation

A data structure for set operations considers data as a collection S1.., Sl of sets over the universe set Z.

set operations includes: Union, Intersection, Sum.

Data owner firstly init (s, g:public key), and then use `bilnear accumulator primitive` to calculate digest for eac set. 

<img src="imgs/image-20220226171006104.png" alt="image-20220226171006104" style="zoom:50%;" />

**Client get above digest, how to verify Sum of set S = {x1...xn}.**

1. server compute:

<img src="imgs/image-20220226171610719.png" alt="image-20220226171610719" style="zoom:50%;" />

2. server then release a1 and a0, compute w1, w2 with g and then realse them also.

   <img src="imgs/image-20220226172610947.png" alt="image-20220226172610947" style="zoom:50%;" />

3. client check follows:

   <img src="imgs/image-20220226172038309.png" alt="image-20220226172038309" style="zoom:50%;" />

**Complexity**

Proofs are constant size. eg,. query involving d set operations, proof size is O(d)







# OUR CONSTRUCTION

# ADDITIONAL DISCUSSION

# IMPLEMENTATION

# EVALUATION

