I" <h1 id="1-schema-design-avoid-hotpot">1. Schema design (avoid hotpot)</h1>

<h2 id="relations">Relations</h2>

<p>Database -&gt; schema -&gt; (tables, views, sequences)</p>

<h2 id="schema-best-practices">Schema best practices</h2>

<p>If need multiple tables with same name, do so in different schema in same DB</p>

<p>use <strong>schema_name.table_name</strong> to access table</p>

<p>Make transactions smaller by operating on less data per transaction. This will offer fewer opportunities  for transactions’ data access to overlap.</p>

<p><a href="https://www.cockroachlabs.com/docs/v21.1/split-at">Split the table across multiple ranges</a> to distribute its data across multiple nodes for better load balancing of some write-heavy workloads.</p>

<pre><code class="language-sql">SHOW RANGES FROM TABLE users
</code></pre>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154031616.png" alt="image-20211028154031616" /></p>

<h2 id="table-best-practices">Table best practices</h2>

<h3 id="create-tables">Create tables:</h3>

<pre><code class="language-sql">CREATE TABLE database_name.schema_name.table_name
</code></pre>

<h3 id="create-columns">Create Columns:</h3>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154306793.png" alt="image-20211028154306793" /></p>

<p>Values exceeding 1MB can lead to write amplification（写放大） and cause performance degradation</p>

<h3 id="set-index-one-or-more-columns-properly">Set index (one or more columns )properly:</h3>

<ol>
  <li>
    <p>Must be <strong>unique and not-null values</strong></p>
  </li>
  <li>
    <p>Set to all <strong>col used for sorting or filter</strong> (=,in )</p>
  </li>
  <li>
    <p>Use storing to store <strong>hot data cols in index</strong>, and also store join key.</p>

    <p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154437616.png" alt="image-20211028154437616" /></p>
  </li>
  <li>
    <p>l Avoid <strong>define pk over a single column of sequential data, eg. auto-incrementing INT or timestamp value</strong></p>
  </li>
  <li>
    <p>l If must define in sequential keys, use hash-sharded index.</p>

    <p>Hash-sharded indexes distribute sequential traffic uniformly across ranges, eliminating single-range hotspots and improving write performance on sequentially-keyed indexes at a small cost to read performance.</p>

    <p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154505841.png" alt="image-20211028154505841" /></p>

    <p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154513220.png" alt="image-20211028154513220" /></p>
  </li>
  <li>
    <p>When possible, define primary key constraints over multiple columns (i.e., use composite primary keys).</p>

    <p>The first col is well-distributed across nodes, and second col can be monotonically increasing pk</p>
  </li>
  <li>
    <p>l For single-column pk, use UUID, gen_random_uuid() function, which ensure the pk value will be unique and well-distributed across a cluster</p>

    <p><strong>这个uuid无法用于查询，但是可以用于多个表的join</strong></p>

    <p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154636919.png" alt="image-20211028154559441" /></p>
  </li>
</ol>

<p>Add proper column constraints</p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154636919.png" alt="image-20211028154636919" /></p>

<p>Secondary index:</p>

<p>​	Unique constrain will set se-index automatically</p>

<h2 id="advanced-schema-design">Advanced schema design</h2>

<h3 id="computed-cols">Computed cols</h3>

<p>Useful when table is frequently sorted</p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154732484.png" alt="image-20211028154732484" /></p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028154736635.png" alt="image-20211028154736635" /></p>

<h3 id="column-families">Column families</h3>

<p>reduce the number of keys stored in the key-value store, resulting in improved performance during <a href="https://www.cockroachlabs.com/docs/v21.1/insert">INSERT</a>, <a href="https://www.cockroachlabs.com/docs/v21.1/update">UPDATE</a>, and <a href="https://www.cockroachlabs.com/docs/v21.1/delete">DELETE</a> operations.</p>

<p>Assign frequently updated col to a single family</p>

<p>https://www.cockroachlabs.com/docs/v21.1/column-families</p>

<h3 id="partial-index">Partial index</h3>

<p>Add index to part of rows and cols</p>

<h3 id="spatial-index">Spatial index</h3>

<h3 id="multiple-region">Multiple region</h3>

<h1 id="2-write-dataread-data">2. Write data/read data</h1>

<h2 id="insert">Insert</h2>

<p>Batch multiple rows in one multi-row insert statement, use batch (10,100, 1000)</p>

<p>Do not include multi-row insert statements with an explicit tx</p>

<h2 id="update">Update</h2>

<p>Must use where.</p>

<p>Use batch-update loop to update many rows (https://www.cockroachlabs.com/docs/v21.1/bulk-update-data)</p>

<p>Wrap the update with retry (https://www.cockroachlabs.com/docs/v21.1/error-handling-and-troubleshooting#transaction-retry-errors)</p>

<h2 id="follower-read">Follower read</h2>

<p>https://www.cockroachlabs.com/docs/v21.1/follower-reads.html</p>

<p>Follower reads are a mechanism that CockroachDB uses to provide faster reads in situations where you can afford to   read data that may be slightly less than current (using <a href="https://www.cockroachlabs.com/docs/v21.1/as-of-system-time"><code>AS OF SYSTEM TIME</code></a>)</p>

<p>Requirements</p>

<ol>
  <li>Read latency is low, but write latency is higher</li>
  <li>Read can be historical (4.8 second or more in past)</li>
  <li>Available during region failure</li>
</ol>

<h1 id="3-manage-txs">3. Manage Txs</h1>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028155026069.png" alt="image-20211028155026069" /></p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028155032359.png" alt="image-20211028155032359" /></p>

<h2 id="retry">Retry:</h2>

<p>System automatic retry</p>

<p>​	Require the insert/update/delete without ”returning”, and have small returned 	result size.</p>

<p>​	If returned result is greater than 16kb, cannot retry</p>

<p>Client side retry:</p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20211028155113030.png" alt="image-20211028155113030" /></p>

<h2 id="nested-tx">Nested tx</h2>

<p>Can rollback to any position in sub tx</p>

<h1 id="4-optimize-performance">4. Optimize performance</h1>

<p>https://www.cockroachlabs.com/docs/v21.1/make-queries-fast.html</p>

<p>https://www.cockroachlabs.com/docs/v21.1/performance-best-practices-overview#understanding-and-avoiding-transaction-contention</p>

<h2 id="avoid-transaction-contention">Avoid transaction contention</h2>

<h3 id="contention">Contention</h3>

<ol>
  <li>Tx operates on <strong>same range,</strong> but different index key value, limited by single node hardware</li>
  <li>Tx operates on <strong>same index key values</strong>, will be more strictly serialized to obey Tx isolation semantics</li>
</ol>

<h3 id="multiple-strategies">Multiple strategies</h3>

<ol>
  <li>Use proper index to distribute the range to multiple nodes</li>
  <li>Make tx small</li>
  <li>Avoid multiple client-server exchanges per transaction, group select, insert etc together in single SQL</li>
  <li>Select for update for scenario of read and then update</li>
  <li>User upsert when replacing values in row</li>
  <li>Do normalization to the table</li>
  <li>If the application strictly requires operating on very few different index key values, consider  using <a href="https://www.cockroachlabs.com/docs/v21.1/split-at">ALTER … SPLIT AT</a> so that each index key value can be served by a separate group of nodes in    the cluster.</li>
</ol>

:ET