I"<h1 id="introduction">Introduction</h1>

<p>In a serverless platform, the application is composed of functions. Users can define functions and <strong>declare events that trigger each function.</strong> The FaaS monitors each triggering event and allocate a runtime for the function, and then executes it.</p>

<p>Benefits:</p>

<p><strong>PayAsYouGo:</strong> The user is billed only for computing resources used during function invocation.</p>

<p><strong>Autoscaling</strong>: The workload automatically drives the allocations and deallocation of resources.</p>

<p><strong>ManageFree</strong>: Users don‚Äôt need to manage the infrastructure.</p>

<p>However, it is not suitable for some applications:</p>

<ol>
  <li>
    <p><strong>Data-intensive application</strong></p>
  </li>
  <li>
    <p><strong>Application with distributed protocol</strong></p>
  </li>
</ol>

<h1 id="suitable-use-cases">Suitable use cases</h1>

<p>Current FaaS are attractive for <strong>simple</strong> workloads of <strong>independent</strong> tasks,</p>

<ol>
  <li>Serverless computing is suitable for functions with fewer communications and requires high parallelism, eg, image pre-processing.</li>
  <li>Also, it is suitable for applications requiring autoscaling, eg. autoscaling dataflow service.</li>
  <li>Applications with functions chain. SQS or S3 can be used as middleware.</li>
</ol>

<h1 id="limitations">Limitations</h1>

<h2 id="limits">Limits</h2>

<p>The serverless has the following limitations, and it is not suitable for some applications.</p>

<ol>
  <li><strong>Short-live</strong> Limited lifetimes and cannot ensure statefully. ( one function can cach states in the hosting VM to support warm start, but subsequent invocations cannot be ensured to run on the same VM. )</li>
  <li><strong>Not-Addressable</strong>: Functions are not network-addressable while running and cannot communicate directly. So they have to maintain states in S3, and communicate through slow storage,</li>
  <li>Each VM has <strong>limited I/O bandwidth</strong>. AWS appears to attempt to pack Lambda functions from the same user together on a single VM, leading to many functions sharing the limited bandwidth.</li>
  <li>No specialized hardware: No API to access <strong>specific hardware</strong>, and FaaS only allow users to use timeslice of CPU hyper-thread and some RAM.</li>
</ol>

<p>In serverless, it runs as a ‚Äúship data to computation‚Äù pattern instead of a ‚Äúship computation to data‚Äù pattern.</p>

<p>Unfeasible applications:</p>

<ol>
  <li><strong>Data-intensive application with more I/O</strong>: Shiping data into computation incurs latency and cost.</li>
  <li><strong>Distributed protocols:</strong> Communication through slow storage is not suitable for distributed protocols with fine-grained communication patterns.</li>
  <li><strong>Hardware required applications</strong>: GPU</li>
</ol>

<h2 id="case-studies">Case studies</h2>

<h3 id="model-training">Model Training</h3>

<p>The paper conducts a model training task on both lambda and EC2, and it found algorithm on Lambda is 21X <strong>slower</strong> and 7.3X more <strong>expensive</strong> than running on EC2.</p>

<p>This is because EC2 fetch data is much faster than in Lambda, (0.04s vs 0.14s)</p>

<h3 id="model-inference">Model Inference</h3>

<p>Using SQS to batch 10 messages at a time, and measure average latency over 1000 batch invocations.</p>

<ol>
  <li>Retrieve the model and write the result back to S3: Lambda is 559ms per batch.</li>
  <li>Complied model into function and wrote result back to SQS: Lambda is 447ms per batch</li>
  <li>EC2: 13ms per batch, 27X faster than Lambda. 2.8ms per batch if retrieve the message locally.</li>
</ol>

<p>As for pricing, if we scale the service to handle 1000 K messages a second,</p>

<ol>
  <li>SQS request rage costs $1584 per hour.</li>
  <li>290 EC2 instances cost $27.84 per hour</li>
</ol>

<h3 id="distributed-computing">Distributed Computing</h3>

<p>Measure latency of retrieving 1kb data.</p>

<p><img src="https://github.com/NLGithubWP/tech-notebook/raw/master/img/a_img_store/image-20220614201620002.png" alt="image-20220614201620002" /></p>

<h1 id="some-key-challenges-for-cloud-provider">Some key challenges for Cloud provider</h1>

<ol>
  <li>
    <p>infrastructure should physically colocate code and data. partition data to match code needs.</p>
  </li>
  <li>
    <p>FaaS offerings should enable upfront SLOs that are priced accordingly</p>
  </li>
  <li>
    <p>Functions should be addressable and can long run.</p>
  </li>
  <li>
    <p>Security: Allowing code to move fluidly toward shared data storage is potentially tricky: rogue code can gather signals across customers.</p>

    <p>SGX‚Äôs enclave can help to protect running code.</p>
  </li>
</ol>

<h1 id="cloud-native-programming">Cloud-Native programming</h1>

<ol>
  <li>
    <p>Communication should asynchronous and flow-based.</p>

    <p>The sequential metaphor of procedural programming will not scale to the cloud, the code should work in small, granular units.</p>
  </li>
</ol>

:ET